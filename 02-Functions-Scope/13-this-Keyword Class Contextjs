class Animal {
    constructor(name) {
        // Constructor me 'this' current instance ko refer karta hai
        this.name = name;
    }
    
    speak() {
        // Normal method â€” yahan 'this' bhi instance ko refer karega
        console.log(`${this.name} makes a sound`);
    }
    
    delayedSpeak() {
        // Agar hum normal function use karte:
        // setTimeout(function() { this.speak(); }, 1000);
        // to 'this' lost ho jata (undefined ho jaata)
        //
        // Arrow function ka fayda:
        // Arrow function ke paas apna 'this' nahi hota,
        // wo outer lexical scope (yani delayedSpeak method) ka 'this' inherit karta hai.
        //
        // So, 'this' yahan bhi Animal instance (dog) hi rahta hai.
        setTimeout(() => {
            this.speak();
        }, 1000);
    }
}

const dog = new Animal("Rex");

dog.speak(); 
// âœ… Output: "Rex makes a sound"
// Normal direct call, 'this' = dog instance

dog.delayedSpeak(); 
// âœ… Output (after 1 second): "Rex makes a sound"
// Because arrow function preserved 'this'


//  ðŸ‘‰ Key Takeaways:
// class methods automatically run in strict mode.

// Inside class methods, this refers to the instance of that class.

// Normal functions inside callbacks (like setTimeout) lose this.

// Arrow functions donâ€™t have their own this, they inherit from parent scope â†’ thatâ€™s why this works correctly he